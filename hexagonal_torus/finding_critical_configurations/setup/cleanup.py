#--------------------------------------------------------------------------
# 
#  Copyright (c) 2013, Lawrence Livermore National Security, LLC.  Produced
#  at the Lawrence Livermore National Laboratory.  Written by Jeremy Mason,
#  reachable at jkylemason@gmail.com.
#  
#  CODE-636759. All rights reserved.
#  
#  This file is part of the Critical Configurations of Hard Disks on the 
#  Torus.  Please read LICENSE.txt for Our Notice and GNU General Public 
#  License information.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License (as published by
#  the Free Software Foundation) version 2, dated June 1991.
# 
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the IMPLIED WARRANTY OF
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the terms and
#  conditions of the GNU General Public License for more details.
# 
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#--------------------------------------------------------------------------
#
#  After generate_function.m, this script should be called in the setup 
#  directory as follows:
#
#  > python3 cleanup.py
#
#--------------------------------------------------------------------------

import os
import re

def cleanup(pathname):
    '''
    Cleans up symbolic functions generated by MATLAB
    Results in valid MATALB code
    '''
    with open(pathname, encoding='utf-8') as a_file:
        a_string = a_file.read()
        
        # Substitutes scalar operations for array operations
        a_string = re.sub(r'\.(?=[*/^])', '', a_string)

        # Replace frequent fractions with simpler expressions
        a_string = re.sub(r'\(1\.0/2\.0\)', '0.5', a_string)
        a_string = re.sub(r'\(1\.0/4\.0\)', '0.25', a_string)
        a_string = re.sub(r'\(3\.0/2\.0\)', '1.5', a_string)

        # Replaces derivatives of periodic_x with 1.0
        a_pattern = re.compile(r'D\(periodic_x\d+\)\(t\d+\)')
        a_string = a_pattern.sub('1.0', a_string)

        # Replaces derivatives of periodic_y with 1.0
        a_pattern = re.compile(r'D\(periodic_y\d+\)\(t\d+\)')
        a_string = a_pattern.sub('1.0', a_string)

        # Propagate variables defined as 1.0
        a_pattern = re.compile(r'(t\d+) = 1.0;\n')
        subs = a_pattern.findall(a_string)
        a_string = a_pattern.sub('', a_string)
        for var in subs:
            a_string = re.sub(var+r'\b', '1.0', a_string)

        # Replaces variables defined as squares of 1.0 with 1.0
        a_pattern = re.compile(r'(t\d+) = 1\.0\^2;\n')
        subs = a_pattern.findall(a_string)
        a_string = a_pattern.sub('', a_string)
        for var in subs:
            a_string = re.sub(var+r'\b', '1.0', a_string)

        # Removes 1.0 from products
        a_string = re.sub(r'(1\.0\*)+', '', a_string)
        a_string = re.sub(r'(\*1\.0)+', '', a_string)

        # Replaces second derivatives of periodic_x with 0.0
        a_pattern = re.compile(r'(t\d+) = D\(D\(periodic_x\d+\)\)\(t\d+\);\n')
        subs = a_pattern.findall(a_string)
        a_string = a_pattern.sub('', a_string)
        for var in subs:
            a_string = re.sub(var+r'\b', '0.0', a_string)

        # Replaces second derivatives of periodic_y with 0.0
        a_pattern = re.compile(r'(t\d+) = D\(D\(periodic_y\d+\)\)\(t\d+\);\n')
        subs = a_pattern.findall(a_string)
        a_string = a_pattern.sub('', a_string)
        for var in subs:
            a_string = re.sub(var+r'\b', '0.0', a_string)

        # Replaces variables defined as a product with 0.0 with 0.0
        a_pattern = re.compile(r'(t\d+) = (?:[.\w]+\*)*0\.0(?:\*[.\w]+)*;\n')
        subs = a_pattern.findall(a_string)
        a_string = a_pattern.sub('', a_string)
        for var in subs:
            a_string = re.sub(var+r'\b', '0.0', a_string)

        # Removes products with 0.0
        a_string = re.sub(r'(?:[.\w]+\*)*0\.0(?:\*[.\w]+)*', '0.0', a_string)

        # Removes 0.0 from sums
        a_string = re.sub(r'(\+0\.0)+', '', a_string)
        a_string = re.sub(r'(-0\.0)+', '', a_string)

        # Replaces one argument of periodic_x and periodic_y with two arguments
        a_pattern = re.compile(r'periodic_[xy](\d+)\(0.0\)')
        subs = a_pattern.findall(a_string)
        for grp in subs:
            a_string = re.sub(
                    r'(?<=periodic_[xy])'+grp[0]+r'\(0.0\)',
                    r'(0.0,0.0,'+grp[0]+r')',
                    a_string)

        # Substitutes for arguments of periodic_x and periodic_y
        a_pattern = re.compile(r'(t\d+) = ([xy]\d+-[xy]\d+);\n')
        subs = a_pattern.findall(a_string)
        a_string = a_pattern.sub('', a_string)
        for grp in subs:
            a_string = re.sub(grp[0]+r'\b', grp[1], a_string)

        # Replaces one argument of periodic_x and periodic_y with two arguments
        a_pattern = re.compile(r'periodic_[xy](\d+)\([xy](\d+)-[xy](\d+)\)')
        subs = a_pattern.findall(a_string)
        for grp in subs:
            a_string = re.sub(
                    r'(?<=periodic_[xy])'+grp[0]+r'\([xy]'+grp[1]+r'-[xy]'+grp[2]+r'\)',
                    r'(x'+grp[1]+r'-x'+grp[2]+r',y'+grp[1]+r'-y'+grp[2]+r','+grp[0]+r')',
                    a_string)

        
        # Replaces periodic_x, periodic_y with periodic_xy. ADDED BY OZAN 10/28/2020.
        a_pattern = re.compile(r'[t](\d+) = periodic_[x]\([x](\d+)-[x](\d+),[y](\d+)-[y](\d+),(\d+)\)\;\n[t](\d+) = periodic_[y]\([x](\d+)-[x](\d+),[y](\d+)-[y](\d+),(\d+)\)\;')
        subs = a_pattern.findall(a_string)
        for grp in subs:
            #print(grp)
            a_string = re.sub(
                    r'[t]'+grp[0]+r' = periodic_[x]\([x](\d+)-[x](\d+),[y](\d+)-[y](\d+),(\d+)\)\;\n[t](\d+) = periodic_[y]\([x](\d+)-[x](\d+),[y](\d+)-[y](\d+),(\d+)\)\;',
                    r'v = periodic_xy(x'+grp[1]+r'-x'+grp[2]+r',y'+grp[1]+r'-y'+grp[2]+r','+grp[5]+r');\nt'+grp[0]+r' = v(1);\nt'+grp[6]+r' = v(2);',
                    a_string)
        
    (dirname, filename) = os.path.split(pathname)
    with open(os.path.join(dirname, filename), mode='w', encoding='utf-8') as a_file:
        a_file.write(a_string)

if __name__ == '__main__':
    cleanup('radius.m')
    cleanup('energy.m')
    cleanup('jacobian.m')
    cleanup('hessian.m')
